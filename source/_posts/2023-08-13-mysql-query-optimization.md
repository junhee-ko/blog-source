---
layout: post
title: "쿼리 작성 및 최적화" 
date: 2023-08-13
categories: MySQL
---

## SELECT

select 쿼리의 각 부분에 사용될 수 있는 기능을 성능 위주로 보자.

### SELECT 절의 처리 순서

1. WHERE 적용 및 조인 실행
2. GROUP BY
3. DISTINCT
4. HAVING 조건 적용
5. ORDER BY
6. LIMIT

### WHERE 절, GROUP BY 절, ORDER BY 절의 인덱스 사용

where 절의 조건뿐만 아니라 group by, order by 절도 인덱스를 이용해 빠르게 처리할 수 있다.

#### 인덱스를 사용하기 위한 기본 규칙

where 절이나 order by 또는 group by 가 인덱스를 사용하려면 기본적으로 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용해야한다.
만약 인덱스는 salary 칼럼으로 만들어져 있는데, 다음처럼 salary 칼럼을 가공한 후 다른 상숭 값과 비교하면 이 쿼리는 인덱스를 이용하지 못한다.

```mysql
select *
from salaries
where salary * 10 > 150000;;
```

#### where 절의 인덱스 사용

where 조건이 인덱스를 사용하는 방법은 크게 작업 범위 결정 조건과 체크 조건의 두 가지 방식으로 구분할 수 있다.
두 방식 중 작업 범위 결정 조건은 where 절에서 동등 비교 조건이나 in 으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서부터 비교했을 때 얼마나 일치하는가에 따라 달라진다.

#### group by 절의 인덱스 사용

group by 절의 각 칼럼은 비교 연산자를 가지지 않으므로 작업 범위 결정 조건이이나 체크 조건과 같이 구분해서 생각할 필요가 없다.
group by 절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면, group by 절은 일단 인덱스를 이용할 수 있다.

1. group by 절에 명시된 칼럼이 인덱스의 칼럼 순서와 위치가 같아야한다.
2. 인덱스를 구성하는 칼럼 중에 뒤쪽에 있는 칼럼은 group by 절에 명시되지 않아도 인덱스를 사용할 수 있다.
3. 인덱스의 앞쪽에 있는 칼럼이 group by 절에 명시되지 않으면 인덱스를 사용할 수 없다.
4. where 조건과 달리 group by 절에 명시된 칼럼이 하나라도 인덱스에 없으면 group by 절은 전혀 인덱스를 이용하지 못한다.

#### ORDER BY 절의 인덱스 사용

group by 의 요건과 비슷하다. 
조건인 하나 더 있다면, 정렬되는 각 칼럼의 오른차순 및 내림차순 옵션이 인덷ㄱ스와 같거나 정반대인 경우에만 사용할 수 있다.

### WHERE 절의 비교 조건 사용시 주의사항

#### null 비교

null 값이 포함된 레코드도 인덱스로 관리된다.
즉, 인덱스에서는 null 을 하나의 값으로 인정해서 관리한다.

#### 문자열이나 숫자 비교

문자열 칼럼이나 숫자 칼럼을 비교할 때는 반드시 그 타입에 맞는 상숫값을 사용하자.

#### 날짜 비교

##### DATE 또는 DATETIME 문자열 비교

DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는, 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다.

#### DATE 와 DATETIME 의 비교

DATETIME 의 값에서 시간 부분만 떼어 버리고 비교하려면, 다음 예제와 괕이 쿼리를 작성하면 된다.

```mysql
select count(*)
from employees
where hire_date > DATE(NOW());
```

### LIMIT n

```mysql
select *
from employees
where emp_no between 10001 and 10010
order by first_name
limit 0, 5;
```

1. employees 테이블에서 where 절긔 검색 조건에 일치하는 레코드를 전부 읽는다.
2. first_name 칼럼 값에 따라 정렬한다.
3. 상위 5건만 사용자에게 반환한다.

limit 의 중요한 특성은, limit 에서 필요한 레코드 건수만 준비되면 즉시 쿼리를 종료한다.
즉, 위 쿼리는 모든 레코드의 정렬이 완료되지 않았어도 상위 5건 까지만 정렬되면 작업을 멈춘다.

### JOIN

#### JOIN 의 순서와 인덱스

조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한번 수행하고, 그 이후부터는 스캔만 실행하면 된다.
하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복한다.
드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지하하는 것이다.

#### JOIN 칼럼의 데이터 타입

조인 칼럼 간의 비교에서 각 칼럼의 데이터 타입이 일치하지 않으면, 인덱스를 효율적으로 사용할 수 없다.

### ORDER BY

order by 절이 없으면,

1. 인덱스를 사용한 select 의 경우, 인덱스에 정렬된 순서대로 레코드를 가져온다.
2. 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하는 select 를 가정해보자. InnoDB 의 경우 항상 프라이머리 키로 클러스터링 되어 있개 때문에 기본적으로 프라이머리 키 순서대로 레코드를 가져온다.
3. select 쿼리가 임시 테이블을 거쳐 처리되면 조회되는 레코드 순서를 예측하기 어렵다.

#### order by 사용법 및 주의사항

order by 뒤에 숫자 값이 아닌 문자열 상수를 사용하면 옵티마이저가 order by 절 자체를 무시한다.

---

Real MySQL 8.0 <백은빈, 이성욱>
