---
layout: post
title: "B-Tree Index #2 - 인덱스 사용에 영향을 미치는 요소" 
date: 2023-08-01
categories: MySQL
---

인덱스 사용에 영향을 미치는 다음 요소들을 정리해보자.

1. 인데스 키 값의 크기
2. B-Tree 깊이
3. Cardinality
4. 읽어야 하는 레코드 건수

## 인데스 키 값의 크기

InnoDB 스토리지 엔진은 디스크의 모든 읽기 및 쓰기 작업의 최소 단위를 page or block 이라고 한다.
페이지 크기의 기본 값은 16KB 이다.

하나의 인덱스 페이지에 저장할 수 있는 키의 개수는,

1. 인덱스의 키가 16 바이트, 자식 노드 주소를 12 바이트: (16 * 1024) / (16 + 12) = 585 개 
2. 인덱스의 키가 32 바이트, 자식 노드 주소를 12 바이트: (16 * 1024) / (32 + 12) = 372 개

SELECT 쿼리가 레코드 500 개를 읽어야한다면, 1번은 인덱스 한 페이지로 해결 가능하고, 2번은 최소 두 번 이상 디스크를 읽어야한다.
즉, 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어나고 그만큼 느려진다.

## B-Tree 깊이

B-Tree 깊이가 3 이면 최대 가질 수 있는 키의 개수는,

1. 인덱스의 키가 16 바이트,  자식 노드 주소를 12 바이트: ((16 * 1024) / (16 + 12)) ^ 3 = 2억 개
2. 인덱스의 키가 32 바이트,  자식 노드 주소를 12 바이트: ((16 * 1024) / (32 + 12)) ^ 3 = 5천만 개

인덱스 키 값의 크기가 커질 수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어진다.
그래서, 같은 레코드 건수라고 하더라도 B-Tree depth 가 깊어져서 디스크 읽기가 더 많이 필요하다.

## Cardinality

Cardinality 란, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
인덱스는 Cardinality 가 높을 수록, 검색 대상이 줄어들어 빠르게 처리된다. 

예를 들어, test 테이블에 country 칼럼과 city 칼럼이 있다고 하자.
전체 레코드 건수는 1만 건이고, country 칼럼만으로 인덱스가 생성된 상태이다.

1. country 칼럼의 유니크한 값의 개수: 10 개
2. country 칼럼의 유니크한 값의 개수: 1,000 개

다음 쿼리를 실행하자.

```mysql
select *
from test
where country = 'KOREA' and city = 'INCHEON';
```

1 케이스는 평균 1,000건 을, 2 케이스는 평균 10건이 조회 될 수 있다는 것을 유니크한 값의 개수로 예측할 수 있다.
만약, 실제 조건을 만족하는 레코드 건 수가 1건만 있었다면 1 케이스는 적합하지 않다.
왜냐하면, 1 케이스는 1건의 레코드를 위해 쓸모없는 999 건의 레코드를 더 읽은 것이고 2 케이스는 9건만 더 읽은 것이다.

## 읽어야 하는 레코드 건수

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
만약 테이블의 레코드가 100 만건이 저장되어 있는데, 50만 건을 읽어야 하는 쿼리가 있으면,

1. 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지
2. 인덱스를 통해 50만 건만 읽어 오는 것이 효율적일지 판단해야한다.

인덱스를 통한 읽기의 손인 분기점이 얼마인지 판단해야하는데, 일반적인 DBMS 의 옵티마이저는 인덱스를 통해 레코드 1 건을 읽는 것이 테이블에서 직접 1 건을 읽는 것보다 4배~5배 정도 비용이 더 드는 것으로 예측한다.
즉, 인덱스를 통해 읽어야하는 레코드 건수가 전체 테이블의 20%~25% 를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적이다.

---

Real MySQL 8.0 <백은빈, 이성욱>
