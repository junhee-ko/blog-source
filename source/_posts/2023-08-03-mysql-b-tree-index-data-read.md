---
layout: post
title: "B-Tree Index #3 - 데이터 읽기"
date: 2023-08-03
categories: MySQL
---

B-Tree 인덱스를 이용하는 대표적인 방법 네 가지를 정리하자.

1. 인덱스 레인지 스캔
2. 인덱스 풀 스캔
3. 루스 인덱스 스캔
4. 인덱스 스킵 스캔

## 인덱스 레인지 스캔

검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식이다.

루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야 비로소 필요한 레코드의 시작점을 찾을 수 있다.
일단 시작해야할 위치를 찾으면 그 때부터는 리프노드의 레코드만 순서대로 읽으면 된다.
만약 스캔하다가 리프 노드 끝가지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아 다시 스캔한다. 
그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.

중요한 것은,인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 단위로 랜덤 I/O 가 한 번씩 일어난다.
쿼리가 필요하는 데이터에 따라, 이 과정이 필요하지 않을 수도 있는데 이것을 커버링 인덱스라고 한다.

## 인덱스 풀 스캔

인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는 방식이다.
대표적으로, 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
예를 들어, 인덱스는 (A, B, C) 칼럼의 순서로 만들어져있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우이다.

일반적으로 인덱스의 크기는 테이블 크기보다 작아서 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적이다.
쿼리가 인덱스에 명시된 칼럼으로 조건을 처리할 수 있으면 이 방식이 사용된다
이 방식은 인덱스 레인스 스캔보다는 빠르지 않고, 테이블 풀 스캔보다는 효율적이다.

인덱스 풀 스캔이 동작하는 방식은,

1. 먼저 인덱스의 리프 노드 제일 앞 또는 제일 뒤로 이동한 후,
2. 인덱스의 리프 노드를 연결하는 linked list 를 따라서 처음부터 끝까지 스캔한다.

## 루스 인덱스 스캔

인덱스 레인지 스캔 방식과 비슷하게 작동하지만, 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어간다.
GROUP BY, MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용된다.

```mysql
select dept_no, MIN(emp_no)
from dept_emp
where dep_no BETWEEN 'd002' AND 'd004';
group by dept_no
```

dept_emp 테이블은 (dep_no, emp_no) 두 개의 칼럼으로 인덱스가 생성되어 있다고 하자.
(dep_no, emp_no) 조합으로 정렬되어 있어서, dept_no 그룹 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.
즉, 인덱스에서 where 조건을 만족하는 범위 전체를 다 스캔할 필요가 없어서 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다.

## 인덱스 스킵 스캔

인덱스를 구성하는 칼럼의 순서가 매우 중요하다. 

employees 테이블에 (gender, birth_date) 조합으로 인덱스가 구성되어 있다고 하자.
이 인덱스를 사용하려면 where 조건에 gender 칼럼에 대한 비교 조건이 필수다.

```mysql
# 인덱스를 사용하지 못함
select gender, birtb_date
from employees
where birtb_date >= '1965-02-01';

# 인덱스를 사용함
select gender, birtb_date
from employees
where gender = 'M' and birtb_date >= '1965-02-01';
```

MySQL 8.0 부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다.
그래서 인덱스 스킵 스캔이 적용된다고 하면 아래의 쿼리는,

```mysql
select gender, birtb_date
from employees
where birtb_date >= '1965-02-01';
```

내부적으로 아래 2개의 쿼리를 실행는 것과 비슷한 형태로 최적화 된다.

```mysql
select gender, birtb_date
from employees
where gender = 'M' and birtb_date >= '1965-02-01';

select gender, birtb_date
from employees
where gender = 'F' and birtb_date >= '1965-02-01';
```

## 다중 칼럼 인덱스

두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스 또는 복합 칼럼 인덱스라고 한다. 

- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬되어 있다.
- 인덱스의 세 번째 칼럼은 두 번째 칼럼에 의존해서 정렬되어 있다.
- ...

## 인덱스의 정렬 및 스캔 방향

인덱스를 생성할 때 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이나 내림차순으로 정렬되어 있다.
인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.

### 인덱스의 스캔 방향

first_name 칼럼에 대한 인덱스가 포함된 employees 테이블에 대해 다음 쿼리를 실행하는 과정을 보자.

```mysql
select *
from employees
order by first_name desc
limit 1;
```

위 쿼리는, 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다.
즉, 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻는다.

```mysql
select *
from employees
where first_name >= 'Anneke'
order by first_name asc
limit 4

select *
from employees
order by first_name desc 
limit 5
```

첫 번째 쿼리는, first_name 칼럼에 정의된 인덱스를 이용해서 "Anneke" 레코드를 찾은 후에, 정순으로 해당 인덱스를 읽으면서 4개의 레코드만 가져오면 된다.
두 번째 쿼리는, first_name 칼럼에 정의된 인덱스를 역순으로 읽으면서 처음 다섯 개의 레코드만 가져오면 된다.

---

Real MySQL 8.0 <백은빈, 이성욱>
