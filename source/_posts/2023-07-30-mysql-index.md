---
layout: post
title: Index
date: 2023-07-30
categories: MySQL
---

## 인덱스

DBMS 는 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.
그래서 컬럼 (또는 칼럼들) 의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 두는 것이다.

그리고 인덱스는 저장된 칼럼의 값을 이용해 항상 정렬된 상태를 유지한다.
데이터 파일은 별도의 정렬 없이 그대로 저장된다.

인덱스가 많은 테이블은 insert, update, delete 문장의 처리가 느려진다.
하지만, 이미 정렬된 인덱스를 가지고 있기 때문에, select 문장의 처리가 빠르다.

인덱스를 역할별로 구분하면 다음과 같이 나눌 수 있다.

1. Primary Key: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스. 식별자라고도 부르고, null 을 허용하지 않고 중복을 허용하지 않는다.
2. Secondary Key: Primary Key 를 제외한 모든 인덱스

데이터 저장 방식 (알고리즘) 별로 구분하면,

1. B-Tree 인덱스: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다. 
2. Hash 인덱스: 칼럼의 값으로 해쉬 값을 계산해서 인덱싱한다.

데이터 중복 허용 여부로 분류하면,

1. Unique Index: 한 건의 레코드만 찾으면 더 찾지 않아도 된다.
2. Non-Unique Index

## B-Tree 인덱스 (Balance) 

데이터베이스의 인덱승싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘이다.

### 구조 및 특성

최상단에 하나의 root node 가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태이다.
트리 구조의 가장 하단에 있는 노드를 leaf node 라고 하고, root node 도 아니고 leaf node 도 아닌 중간에 있는 노드를 branch node 라고 한다.
리프 노드는 항상 실제 데이터의 레코드를 찾아가기 위한 주솟값을 가지고 있다.

인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서대로 저장되어 있다.

인덱스는 테이블의 키 칼럼만 가지고 있으므로, 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야한다.

#### 인덱스 키 추가

B-Tree 에 저장될 때는, 

1. 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야한다.
2. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장해야한다.

리프 노드가 꽉 차서 더 저장할 수 없으면, 리포 노드가 분리되어야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.
그래서, B-Tree 는 쓰기 작업에 비용이 많이 든다.

#### 인덱스 키 삭제

B-Tree 의 키 값이 삭제되는 경우는, 해당 키 값이 저장된 B-Tree 의 리프 노드츷 찾아 삭제 마크만 하면 완료된다.
삭제 마킹된 인덱스의 키 공간은 그대로 방치하거나 방치될 수 있다.

#### 인덱스 키 변경

B-Tree 의 키 값 변경 작업은 먼저 키 값을 삭제한 후에, 다시 새로운 키 값을 추가하는 형태로 처리된다.

#### 인덱스 키 검색

인덱스를 검색하는 작업은 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행한다.

### 인데스 키 값의 크기

InnoDB 스토리지 엔진은 디스크의 모든 읽기 및 쓰기 작업의 최소 단위를 page 또는 block 이라고 한다.

페이지의 크기 기본 값은 16KB 이다.
인덱스의 키가 16 바이트라고 가정하고, 자식 노드 주소를 12 바이트라고 하자.
그럼, 하나의 인덱스 페이지에 몇 개의 키를 저장할 수 있을까 ?
(16 * 1024) / (16+12) = 585 개를 저장할 수 있다.

만약 키 값의 크기가 두 배인 32 바이트라고 하면,
(16 * 1024) / (32+12) = 372 개를 저장할 수 있다.

SELECT 쿼리가 레코드 500 개를 읽어야한다면, 전자는 인덱스 한 페이지로 해결 가능하고, 후자는 최소 두 번 이상 디스크를 읽어야한다.
즉, 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어나고 그만큼 느려진다.

### B-Tree 깊이

페이지의 크기 기본 값은 16KB 이다.
인덱스의 키가 16 바이트라고 가정하고, 자식 노드 주소를 12 바이트라고 하자.
B-Tree 깊이가 3이면 최대 몇개의 키를 가질 수 있을까 ?

((16 * 1024) / (16+12)) ^ 3 = 2억 개 정도의 키를 가질 수 있다.

키 값의 크기가 32 바이트라고 하면,

((16 * 1024) / (32+12)) ^ 3 = 5천만 개로 줄어든다.

즉 인덱스 키 값의 크기가 커질 수록, 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어진다.
그래서, 같은 레코드 건수라고 하더라도 B-Tree depth 가 깊어져서 디스크 읽기가 더 많이 필요하다.

### Cardinality

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
전체 인덱스 키 값은 100 개인데, 유니한 값의 수가 10 개라면 Cardinality 는 10 이다.

인덱스는 Cardinality 가 높을 수록, 검색 대상이 줄어들어 빠르게 처리된다.
예를 들어, tb_test 테이블에 country 칼럼과 city 칼럼이 있다고 하자.
전체 레코드 건수는 1만 건이고, country 칼럼만으로 인덱스가 생성된 상태이다.

1. country 칼럼의 유니크한 값의 개수가 10개
2. country 칼럼의 유니크한 값의 개수가 1,000개

다음 쿼리를 실행하자.

```mysql
select *
from tb_test
where country = 'KOREA' and city = 'INCHEON';
```

1 케이스는 평균 1,000건 을 2 케이스는 평균 10건이 조회 될 수 있다는 것을 유니크한 값의 개수로 예측할 수 있다.
만약, 실제 조건을 만족하는 레코드 건 수가 1건만 있었다면 1 케이스는 적합하지 않다.
왜냐하면, 1 케이스는 1건의 레코드를 위해 쓸모없는 999 건의 레코드를 더 읽은 것이고 2 케이스는 9건만 더 읽은 것이다.


### 읽어야 하는 레코드 건수

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
만약 테이블의 레코드가 100 만건이 저장되어 있는데, 50만 건을 읽어야 하는 쿼리가 있으면

1. 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지
2. 인덱스를 통해 50만 건만 읽어 오는 것이 효율적일지 판단해야한다.

일반적인 DBMS 의 옵티마이저에서는, 인덱스를 통해 읽어야하는 레코드 건수가 전체 테이블의 20~25% 를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적이다.

### B-Tree 인덱스를 통한 데이터 읽기

인덱스를 이용하는 대표적인 방법 네 가지를 정리하자.

1. 인덱스 레인지 스캔
2. 인덱스 풀 스캔
3. 루스 인덱스 스캔
4. 인덱스 스킵 스캔

#### 인덱스 레인지 스캔

검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식이다.
루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야 비로소 필요한 레코드의 시작점을 찾을 수 있다.
일단 시작해야할 위치를 찾으면 그 때부터는 리프노드의 레코드만 순서대로 읽으면 된다.
만약 스캔하다가 리프 노드 끝가지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아 다시 스캔한다. 
그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.

#### 인덱스 풀 스캔

인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는 방식이다.
대표적으로, 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
예를 들어, 인덱스는 (A, B, C) 칼럼의 순서로 만들어져있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우이다.

일반적으로 인덱스의 크기는 테이블 크기보다 작아서 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적이다.
쿼리가 인덱스에 명시된 칼럼으로 조건을 처리할 수 있으면 이 방식이 사용된다
이 방식은 인덱스 레인스 스캔보다는 빠르지 않고, 테이블 풀 스캔보다는 효율적이다.

1. 먼저 인덱스의 리프 노드 제일 앞 또는 제일 뒤로 이동한 후,
2. 인덱스의 리프 노드를 연결하하는 linked list 를 따라서 처음부터 끝까지 스캔한다.

#### 루스 인덱스 스캔

인덱스 레인지 스캔 방식과 비슷하게 작동하지만, 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어간다.
GROUP BY, MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용된다.

```mysql
select dept_no, MIN(dept_no)
from dept_emp
where dep_no BETWEEN 'd002' AND 'd004';
group by dept_no
```

dept_emp 테이블은 (dep_no, emp_no) 두 개의 칼럼으로 인덱스가 생성되어 있다고 하자.
(dep_no, emp_no) 조합으로 정렬되어 있어서, dept_no 그룹 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.
즉, 인덱스에서 where 조건을 만족하는 범위 전체를 다 스캔할 필요가 ㅇ벗다.

#### 인덱스 스킵 스캔

인덱스를 구성하는 칼람의 순서가 매우 중요하다. 
empployees 테이블에 (gender, birth_date) 조합으로 인덱스가 구성되어 있다고 하자.

이 인덱스를 사용하려면 where 조건에 gender 칼럼에 대한 비교 조건이 필수다.

```mysql
# 인덱스를 사용하지 못함
select *
from employees
where birtb_date >= '1965-02-01';

# 인덱스를 사용함
select *
from employees
where gender = 'M' and birtb_date >= '1965-02-01';
```

MySQL 8.0 부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다.

### 다중 칼럼 인덱스

두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스 또는 복합 칼럼 인덱스라고 한다. 

- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬되어 있다.
- 인덱스의 세 번째 칼럼은 두 번째 칼럼에 의존해서 정렬되어 있다.
- ...


### 인덱스의 정렬 및 스캔 방향

인덱스를 생성할 때 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이나 내림차룬으로 정렬되어 있다.
인덱스르 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행계획에 따라 결정된다.

#### 인덱스의 스캔 방향

first_name 칼럼에 대한 인덱스가 포함된 employees 테이블에 대해 다음 쿼리를 실행하는 과정을 보자.

```mysql
select *
from employees
order by first_name desc
limit 1;
```

위 쿼리는, 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다.
즉, 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻는다.

```mysql
select *
from employees
where first_name >= 'Anneke'
order by first_name asc
limit 4

select *
from employees
order by first_name desc 
limit 5
```

첫 번째 쿼리는, first_name 칼럼에 정의된 인덱스를 이용해서 "Anneke" 레코드를 찾은 후에, 정순으로 해당 인덱스를 읽으면서 4개의 레코드만 가져오면 된다.
두 번째 쿼리는, first_name 칼럼에 정의된 인덱스를 역순으로 읽으면서 처음 다섯 개의 레코드만 가져오면 된다.

### B-Tree 인덱스의 가용성과 효율성

#### 비교 조건의 종류와 효율성

다중 칼럼 인덱스에서 각 칼람의 순서와 그 칼럼에 사용된 조건이 동등 비교인지 아니면 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라진다.

```mysql
select *
from demt_emp
where dept_no = 'd002' and emp_no >= 10114;
```

이 쿼리를 위해 칼럼의 순서만 다른 두 가지 케이스로 인덱스를 생성했다고 하자.

1. A index: (dept_no, emp_no)
2. B index: (emp_no, dept_no)

A 인덱스는 "dept_no = 'd002' and emp_no >= 10114" 인 레코드를 찾은 뒤에 dept_no = 'd002' 가 아닐 때 까지 인덱스를 쭉 읽으면 된다.
조건을 만족하는 레코드가 5건 이라고 하면, 5건의 레코드에 대해 비교 작업만 수행하면 된다.

B 인덱스는 "emp_no >= 10114 and dept_no = 'd002'" 인 레코드를 찾은 뒤에 모든 레코드에 대해 dept_no = 'd002' 인지 비교해야한다. 

이처럼 인덱슬르 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 선택하는 작업을 필터리이라고 한다.
B index 는 최종적으로 dept_no = 'd002' 조건을 필터링하는 레코드 5건을 가져온다.

A index 는 두 번째 칼럼인 emp_no 이 비교 작업의 범위를 좁히는데 도움을 주었다. 
B index 는 두 번째 칼럼인 dept_no 비교 작업의 범위를 좁히는데 아무런 도움을 주지 못했다. 단지 쿼리의 조건에 맞는지 검사하는 용도로 사용했다.

---

Real MySQL 8.0 <백은빈, 이성욱>
