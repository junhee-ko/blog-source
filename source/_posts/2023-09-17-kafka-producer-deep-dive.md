---
layout: post
title: "프로듀서의 내부 동작 원리" 
date: 2023-09-17
categories: Kafka
---

프로듀서의 내부 동작 원리에 대해 정리해보자.

1. 파티셔너
2. 배치 전송
3. 압축
4. 전송 방식

## 파티셔너

프로듀서는 토픽으로 메세지를 보낼 때 어느 파티션으로 보내야 할지를 결정해야하는데, 이 때 사용하는 것이 파티셔너이다.
프로듀서가 파티션을 결정하는 알고리즘은 기본적으로 메세지의 키를 hash 처리해서 파티션을 구하는 방식을 사용한다.
그래서, 메세지의 키 값이 동일하면 모두 같은 파티션으로 전송된다.

그런데, 동일한 메세지의 키를 이용해서 메세지를 전송해도 파티션 수를 늘린 후에는 다른 파티션으로 전송될 수 있다.
왜냐하면, 토픽의 파티션 수가 변경되면 메세지의 키와 매핑된 hash table 도 변경되기 때문이다.

이제 다음 전략을 정리해보자.

1. 라운드 로빈 전략
2. 스티키 파티셔닝 전략

### 라운드 로빈 전략

키 값을 지정하지 않는다면, 키 값은 null 이 되고 round-robin 알고리즘을 사용해서 프로듀셔는 토픽의 파티션들로 레코드들을 전송한다.
파티셔너를 거친 후의 레코드들은 배치 처리를 위해 프로듀서의 버퍼 메모리 영역에 잠기 대기한 후 카프카로 전송된다.

메세지들이 대기하는 과정에서 라운드 로빈 전략은 효율을 떨어뜨릴 수 있다.
토픽 A 는 총 3개의 파티션으로 구성되어 있고, 각 파티션별로 배치 전송을 위해 필요한 레코드 수는 3 이라고 하자.

1. 프로듀셔는 키 값이 null 인 레코드 1 을 보내고, 파티셔너는 라운드 로빈 전략으로 토픽A - 파티션0 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)
2. 프로듀셔는 키 값이 null 인 레코드 2 를 보내고, 파티셔너는 라운드 로빈 전략으로 토픽A - 파티션1 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)
3. 프로듀셔는 키 값이 null 인 레코드 3 을 보내고, 파티셔너는 라운드 로빈 전략으로 토픽A - 파티션2 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)
4. 프로듀셔는 키 값이 null 인 레코드 4 를 보내고, 파티셔너는 라운드 로빈 전략으로 토픽A - 파티션0 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)
5. 프로듀셔는 키 값이 null 인 레코드 5 를 보내고, 파티셔너는 라운드 로빈 전략으로 토픽A - 파티션1 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)

라운드 로빈 전략에 의해 각 파티션에 하나씩 순차적으로 할당되었다.
배치 전송을 위한 최소 레코드의 수가 3 으로 설정되어 있기 때문에, 총 5 개의 레코드가 파티셔너를 거쳤지만 카프카로 전송되지 못한 채 프로듀서 내에서 대기하고 있다.

물론, 프로듀셔의 옵션을 조정해서 특정 시간을 초과하면 즉시 카프카로 레코드들을 전송하도록 설정할 수 있다.
하지만, 토픽A - 파티션2 와 같이, 배치와 압축의 효과를 얻지 못한 채 레코드 하나만 카프카로 전송되므로 비효율적이다.

### 스티키 파티셔닝 전략

위에서 보았듯이, 라운드 로빈 전략은 지연 시간이 불필요하게 증가되는 문제가 있다.
이를 해결하기 위해, 2019 년에 출시된 아파치 카프카 2.4 v 부터는 스티키 파티셔닝 전략을 사용하게 된다.
스티키 파티셔닝 전략은, 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송하는 전략이다.

1. 프로듀셔는 키 값이 null 인 레코드 1 을 보내고, 파티셔너는 스티키 파티셔닝 전략으로 토픽A - 파티션0 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)
2. 프로듀셔는 키 값이 null 인 레코드 2 를 보내고, 파티셔너는 스티키 파티셔닝 전략으로 토픽A - 파티션0 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)
3. 프로듀셔는 키 값이 null 인 레코드 3 을 보내고, 파티셔너는 스티키 파티셔닝 전략으로 토픽A - 파티션0 에 담아놓는다. (프로듀서의 버퍼 메모리에 대기)
4. 배치를 위한 레코드 수에 도달했기 때문에, 즉시 카프카로 배치 전송을 한다.

카프카로 전송하는 메세지의 순서가 중요하지 않다면, 스티키 파티셔닝 전략을 사용하자. 

## 프로듀서의 배치 전송

프로듀서의 배치 전송 방식은 단건의 메세지를 전송하는게 아니라, 한 번에 다량의 메세지를 묶어서 전송하는 방법이다.
불필요한 I/O 를 줄일 수 있어서 효율적이다.
프로듀서는 배치 전송을 위해 다음 옵션들을 제공한다.

- buffer.memory: 카프카로 메세지들을 전송하기 위해 담아두는 프로듀서의 버퍼 메모리 옵션 ( default 32MB ) 
- batch.size: 배치 전송을 위해 메세지들을 묶는 단위를 설정하는 배치 크기 옵션 ( default 16KB )
- linger.ms: 배치 전송을 위해 버퍼 메모리에서 대기하는 메세지들의 최대 대기 시간 ( default 0 == 즉시 전송 )

카프카 사용 목적에 따라서, 처리량을 높일지 지연 없는 전송을 해야할지 선택하면 된다.

1. 처리량을 높이려면: batch.size 와 linger.ms 의 값을 크게 설정
2. 지연 없는 전송을 하려면: batch.size 와 linger.ms 을 값을 작게 설정

주의할 점은, buffer.memory 의 값이 충분히 커야하고, batch.size 보다는 커야한다.

1. 만약 토픽이 3개의 파티션을 가지고 있고, batch.size 가 16KB 라고 하면
2. buffer.memory 의 최소 크기는 16KB * 3 이어야한다.
3. 그리고, 프로듀서가 전송에 실패해서 재시도를 수행할 수 있기 때문에, 16KB * 3 보다 더 큰 값으로 설정해야한다. 

## 프로듀서의 압축

배치 전송과 더불어서, 압축 기능을 사용하면 프로듀서는 메세지를 더 효율적으로 카프카에 전송할 수 있다.
아래와 같은 압축 포맷을 지원한다.

1. 높은 압축를이 필요하면: gzip, zstd
2. 낮은 지연 시간이 필요하면: lz4, snappy

## 전송 방식

전송 방식에 대해 정리해보자.

1. 적어도 한 번 전송 ( at-least-once ) 
2. 최대 한 번 전송 ( at-most-once ) 
3. 중복 없는 전송
4. 정확히 한 번 전송 ( exactly-once ) 

### 적어도 한 번 전송

카프카는 기본적으로 at-least-once 기반으로 동작한다.

1. 프로듀서: 브로커의 특정 토픽에 메세지 A 를 전송
2. 브로커: 메세지 A 를 기록하고, ack 를 프로듀서에게 응답
3. 프로듀서: ack 를 받은 뒤에, 다음 메세지 B 를 브로커에 전송
4. 브로커: 메세지 B 를 기록하고, ack 를 프로듀서에게 응답하려고 하는데, 네트워크 오류 or 브로커 장애 발생
5. 프로듀서: 메세지 B 에 대한 ack 를 받지 못했기 때문에, 브로커가 메세지를 받지 못했다고 판단해서 메세지 B 를 재전송

- 만약, 브로커가 메세지 B 를 받지 못한 상황이라면, 브로커는 5 번에서 재전송된 메세지를 처음으로 저장할 것이다.
- 만약, 브로커가 메세지 B 를 저장하고 ack 만 전송하지 못한 상황이라면, 브로커는 5 번에서 재전송된 메세지를 중복 저장할 것이다.

### 최대 한 번 전송

1. 프로듀서: 브로커의 특정 토픽에 메세지 A 를 전송
2. 브로커: 메세지 A 를 기록하고, ack 를 프로듀서에게 응답
3. 프로듀서: 다음 메세지 B 를 브로커에 전송
4. 브로커: 메세지 B 를 기록하지 못하고 , ack 를 프로듀서에게 전송 실패
5. 프로듀서: 브로커가 메세지 B 를 잘 받았다고 가정하고, 메세지 C 를 전송

프로듀서가 메세지 B 를 전송했지만, 중간에 유실되어 브로커가 저장하지 못했을 수도 있고, 브로커가 메세지 B 를 기록했지만 프로듀서에게 ack 만 응답하지 못한 것일 수도 있다.
at-most-once 방식에서는 프로듀서는 메세지의 중복 가능성을 회피하기 위해 재전송을 하지 않는다.

### 중복 없는 전송

카프카 0.11 v 에서 프로듀서가 메세지를 중복 없이 브로커로 전송할 수 있는 기능이 추가되었다.

1. 프로듀서: 브로커의 특정 토픽에 메세지 A 를 전송. 이 때, PID (= producer id) 0 과 메세지 번호 0 을 헤더에 포함
2. 브로커: 메세지 A 를 저장하고, PID 0 과 메세지 번호 0 을 메모리에 기록한 뒤에 ack 를 프로듀서에게 응답
3. 프로듀서: 다음 메세지 B 를 브로커에 전송. 이 때, PID 는 동일하게 0 과 메세지 번호 1 을 헤더에 포함 
4. 브로커: 메세지 B 를 저장하고, PID 0 과 메세지 번호 1 을 메모리에 기록. 그리고, ack 를 프로듀서에 전송 실패
5. 프로듀서: ack 를 받지 못했기 때문에, 메세지 B 를 재전송

적어도 한번 과정과 다른점은, 5번 과정 뒤에 브로커가 메세지를 중복해서 저장하지 않고 ack 만 보낸다는 것이다.
프로듀서가 재전송한 메세지 B 의 헤더에서 PID 0 과 메세지 번호 1을 비교해서 메세지 B 가 이미 브로커에 저장되어 있는 것을 확인하기 때문이다.

중복 없는 전송을 위한 프로듀서의 설정으로는,

- enable.idempotence: 프로듀서가 중복 없는 전송을 허용할지 결정하는 옵션. 설정을 원하면 true 로 한 뒤에, 아래 세 옵션도 변경해야 ConfigException 이 발상히지 않음
- max.in.flight.requests.per.connection: ack 를 받지 않은 상태에서 하나의 connection 에서 보낼 수 있는 최대 요청 수 ( default 5 )
- acks: 프로듀서 acks 와 관련된 옵션. all 로 설정 필요 ( default 1 )
- retries: ack 를 받지 못한 경우 재시도를 해야하므로 0 보다 커야함

### 정확히 한 번 전송

위에서 정리한 중복 없는 전송 방식은 정확히 한 번 전송한다는 의미는 아니다. 
카프카에서 정확히 한 번 전송은 트랜잭션과 같은 전체적인 프로세스 처리를 의미한다.
전체적인 프로세스를 관리하기 위해 카프카에서는 정확히 한 번 처리를 담당하는 별도의 프로세스가 있는데, 이를 트랜잭션 API 라고 한다.

#### 디자인

프로듀서가 카프카로 정확히 한 번 방식으로 메세지를 전송할 때, 프로듀서가 보내는 메세지들은 원자적으로 처리되어 전송에 성공하거나 실패하게 된다.
이런 전송을 위해 카프카에서는 컨슈머 그룹 코디네이터와 같은 개념으로 트랜잭션 코디네이터라는 것이 서버 측에 존재한다.
트랜잭션 코디네이터는 프로듀서에 의해 전송된 메세지를 관리하며, 커밋 또는 중단 등을 표시한다.

컨슈머 오프셋 관리를 카프카 내부 토픽에 저장하는 것 처럼, 트랜잭션 로그를 카프카 내부 토픽에 저장한다.
프로듀서는 트랜잭션 관련 정보를 트랜잭션 코디네이터에게 알리고, 모든 정보의 로그는 트랜잭션 코디네이터가 직접 기록한다.

정확히 한 번 전송을 이용해 전송된 메세지들이 카프카에 저장되면, 카프카의 메세지를 다루는 클라이언트들이 해당 메세지들이 정상적으로 커밋된 것인지 실패된 것인지 알 수 있어야한다.
카프카에서는 이를 식별하기 위한 정보로, 컨트롤 메세지라고 불리는 메세지가 추가로 사용된다.

---

실전 카프카 개발부터 운영까지 <고승범>
