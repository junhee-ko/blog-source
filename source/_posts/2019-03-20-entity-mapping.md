---
layout: post
title: Entity Mapping
date: 2019-03-20
categories: JPA
---

엔티티와 테이블을 정확히 매핑하기 위해 JPA 는 다양한 어노테이션을 지원한다.

1. 객체와 테이블 매핑 : @Entity, @Table
2. 기본 키 매핑 :@Id
3. 필드와 컬럼 매핑 : @Column

## @Entity

JPA 를 사용해서 테이블을 매핑할 클래스는 @Entity 를 필수로 붙여야한다. 
그리고, @Entity 적용시 기본 생성자는 필수이다.

## @Table

엔티티와 매핑할 테이블을 지정한다.

## 데이터베이스 스키마 자동 생성

JPA 는 클래스의 매핑 정보와 Database Dialect 을 사용해서 데이터베이스 스키마를 생성한다.
create / create-drop / update / validate / none 옵션이 있다.
다음과 같이 설정하면 기존 테이블은 삭제하고 새로 생성한다. ( DROP + CREATE )

```java
spring.jpa.hibernate.ddl-auto=create
```

## Primary Key 매핑

JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다.

1. 직접 할당 : 애플리케이션에서 직접 할당한다.
2. 자동 생성 : 대리 키를 사용한다.

### 직접 할당

em.persist() 로 엔티티를 영속성 컨텍스트에 저장하기 전에, 애플리케이션에서 키를 직접 할당하는 방식이다.

```java
   Board b = new Board();
   b.setId("id1");
   em.persist(b);
```

### 자동 생성 01 : IDENTITY

기본 키 생성을 데이터베이스에 위임한다. 그래서, DB 에 값을 저장하고 나서야 기본 키 값을 얻을 수 있다.
그런데, 엔티티가 영속성 상태가 되려면 식별자가 반드시 필요하다. IDENTITY 식별자 생성 전략은 이 전제를 어떻게 해결할까 ?

1. em.persist() 를 호출한다.
2. 즉시 INSERT SQL 이 DB 에 전달된다. 
   
그래서, Transactional Write Behind 가 동작하지 않는다.

그런데, INSERT 한 후에 기본 키 값을 다시 조회하기 위해 추가적으로 SELECT 를 할까 ? 아니다.
JDBC3 에 추가된 Statement.getGeneratedKeys() 를 사용하여 데이터를 조회하는 동시에 생성된 기본키도 얻을 수 있다.

### 자동 생성 02 : SEQUENCE

데이터베이스 시퀀스를 사용해 기본 키를 할당한다. 데이터베이스 시퀀스란, 유일한 값을 순서대로 생성하는 특별한 DB Object 이다.
이 전략은, 시퀀스를 지원하는 PostgreSQL, DB2, H2 데이터베이스에 사용할 수 있다.
SEQUENCE 전략은 

1. em.persist() 를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회한다.
2. 조회한 식별자를 엔티티에 할당한다.
3. 엔티티를 영속성 컨텍스트에 저장한다.
4. 트랜잭션을 커밋해서 플러쉬가 일어난다.
5. 엔티티를 데이터베이스에 저장한다.


### 자동 생성 03 : TABLE

키 생성 전용 테이블을 하나 만드는 방법이다.
시퀀스 대신에 테이블을 사용한다는 것만 제외하면, SEQUENCE 전략과 동일하다.

## 식별자 선택 전략

DB 기본키는 다음 조건을 만족해야한다.

1. null 허용 X
2. 유일
3. 불변

테이블의 기본 키를 선택하는 전략은,

1. 자연키 : 비즈니스에 의미있는키 (ex) 주민번호
2. 대리키 : 비즈니스와 관련 없는 임의 키 (ex) auto_increment

그렇다면, 자연키가 나을까 대리키가 나을까 ? 대리키가 낫다.
왜냐하면, 비즈니스 요구사항은 변할 수 있기 때문이다. 요구사항은 계속 변하는데, 테이블은 한 번 정의하면 변경하기 어렵다.

---
자바 ORM 표준 프로그래밍 <김영한>