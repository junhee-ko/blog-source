---
layout: post
title: "쿠버네티스 자원 사용량 제한"
date: 2020-12-15
categories: K8S
---

k8s 같은 컨테이너 오케스트레이션 툴의 장점은, 여러 대의 서버를 묶어 리소스를 풀로 사용할 수 있다는 것이다.
그래서, 클러스터 내부에서 컴퓨팅 자원 활용률을 늘리는 것이 중요하다.

## 컨테이너와 포드의 자원 사용량 제한: Limit

자원 할당량을 설정하지 않으면 포드의 컨테이너가 노드의 물리 자원을 모두 사용해서 노드의 자원이 모두 고갈될 수 있다.
이를 예방하기 위해, 포드 자체에 자원 사용량을 명시할 수 있다.
limits 는 해당 포드의 컨테이너가 최대로 사용할 수 있는 자원의 상한선이다.

```yaml
apiVersion: v1
kind: Pod
...
spec:
  resources:
    limits:
      memory: "256Mi"
      cpi: "1000m" # 1개의 CPU 를 뜻함 (1000 밀리코어)
```

## 오버커밋

오버커밋이란, 한정된 컴퓨팅 자원을 효율적으로 사용하기 위한 방법이다.
사용할 수 있는 자원보다 더 많은 양을 가상 머신이나 컨테이너에게 할당해서 전체 자원 사용률을 높이는 것이다.

## 컨테이너와 포드의 자원 사용량 제한: Request

1GB 메모리를 가지는 하나의 서버에 A, B 두 컨테이너를 생성했다고 하자. 
각 컨테이너에는 500MB 메모리를 할당했다.
A 컨테이너는 메모리를 거의 사용하고 있지 않고, B 컨테이너는 상한선인 500 MB 를 거의 사용하고 있다고 해보자.
A 컨테이너가 사용하고 있지 않은 유휴 자원을 B 컨테이너에게 빌려주면 좋지만, 자원 제한을 정적으로 설정해서 B 컨테이너는 500 MB 보다 더 많은 메모리를 사용할 수 없다.
A 컨테이너 메모리 사용률이 낮다면, 컨테이너 B 는 A 컨테이너 의 남는 메모리 자원을 사용할 수 있게 해주는 것이, Limit 이다.

그런데, A 컨테이너가 500MB 를 사용하고 있는데 B 컨테이너가 750MB 를 사용하려 시도하면, 메모리 충돌이 일어나 두 컨테이너의 프로세스가 비정상 종료를 할 수 있다.
그래서, 각 컨테이너가 사용을 보장받을 수 있는 경계선이 필요하다. 이것이 Request 이다.
즉, Requests 는 적어도 이만큼의 자원은 컨테이너에게 보장되어야한다는 것을 의미한다.

```yaml
...
  resources:
    limits:
      memory: "256Mi"
      cpu: "1000M"
    requests:
      memory: "128Mi"
      cpu: "500M"
```

위 의미는, 최소한 "128Mi" 메모리 사용은 보장되고 유휴 메모리 자원이 있으면 "256Mi" 까지 사용할 수 있다는 의미이다.

## QoS 클래스와 메모리 자원 사용량 제한 원리

하나의 노드에서 여러 개의 컨테이너가 Request 보다 더 많은 자원을 사용하려고 시도하면, 가용 메모리 확보를 위해 우선순위가 낮은 포드나 프로세스를 강제로 종료해야한다.
강제로 종료된 포드는 다른 노드로 옮겨가는데, 이것을 eviction 이라고 한다.

그럼, 어떤 포드나 프로세스가 먼저 종료되어야 할까 ?
k8s 는 포드의 컨테이너에 설정된 Limit, Request 값에 따라 우선순위를 계산한다.
또한, 우선순위 구분을 위해 아래 세 종류의 Quality of Service (QoS) 클래스를 포드에 설정한다.

### Guaranteed Class

Guaranteed 클래스는 포드의 컨테이너에 설정된 Limit 과 Request 의 값이 완전히 동일할 때 부여되는 클래스이다.
Guaranteed 클래스로 분류되는 포드는, Limit 과 Request 값이 동일해서 자원의 오버커밋이 허용되지 않아 할당 받은 자원의 사용을 안정적으로 보장받는다.

### BestEffort Class

Limit 과 Request 를 아예 설정하지 않은 포드에 설정되는 클래스이다.
BestEffort 클래스의 포드는 Limit 값을 설정하지 않아서, 노드에 유휴 자원이 있다면 제한 없이 모든 자원을 사용할 수 있다.
또한, Request 또한 설정하지 않아서 사용을 보장받을 수 있는 자원이 존재하지 않는다.

### Burstable Class

Limit 과 Request 가 설정되어있지만, Limit 의 값이 Request 보다 큰 포드에 설정되는 클래스이다.
그래서, Request 에 지정된 자원만큼 사용을 보장받지만 상황에 따라 Limit 까지 자원을 사용할 수 있다.
즉, 필요에 따라 순간적으로 자원의 한계를 확장해 사용할 수 있는 포드다.

### Qos Class, 메모리 부족

포드의 우선순위는 Guaranteed 가 가장 높고, 그 뒤로 Burstable, BestEffort 순이다.
그래서, 노드에 메모리가 부족하면 BestEffort 가 가장 먼저 종료된다.

하지만, 이 우선순위가 절대적이지 않다.
포드가 메모리를 많이 사용하면 사용할 수록, 우선순위가 낮아진다.

## ResourceQuota 와 LimitRange

ResourceQuota 와 LimitRanger 오브젝트는 자원 사용량을 관리할 수 있는 기능을 제공한다.
ResourceQuota 를 이용해 namespace 의 자원 사용량을 제한하고, LimitRanger 로 자원 할당의 기본 값이나 범위를 설정할 수 있다.

### ResourceQuota 로 자원 사용량 제한

ResourceQuota 는 특정 namespace 에서 사용할 수 있는 자원 사용량의 합을 제한할 수 있는 오브젝트이다.

1. namespace 에서 할당 할 수 있는 자원의 총합을 제한
2. namespace 에서 생성할 수 있는 리소스의 개수를 제한

### LimitRange 로 자원 사용량 제한

LimitRange 는 특정 namespace 에서 할당되는 자원의 범위 또는 기본값을 지정할 수 있는 오브젝트이다.

1. 포드의 컨테이너에 CPU 나 메모리 할당량이 설정되어 있지 않으면, 컨테이너에 자동으로 기본 request or limit 값을 설정한다.
2. 포드나 컨테이너의 CPU, 메모리의 최솟값, 최댓값을 설정한다.

---

시작하세요! 도커/쿠버네티스 <용찬호>